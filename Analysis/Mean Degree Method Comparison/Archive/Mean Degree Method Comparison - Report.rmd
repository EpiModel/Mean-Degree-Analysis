---
title: | 
 | Mean Degree of Ongoing Partnerships-
 | Day-of-Survey versus Three-Month Offset Method
header-includes:
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage{xcolor}
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Purpose

To compare two methods of determining the mean degree of ongoing casual and main partnerships using response data from the ART-net study.

## Description

Mean degree is an important measure of network connectivity which represents the average number of edges connected to a node/vertex. In this context, mean degree represents the average number of concurrent ongoing partners of an individual enrolled in the ART-net study.
The American Men's Internet Survey (AMIS), from which the ART-net study sources data, explicitly asks individuals about ongoing partnerships. Mean degree can be calculated through analysis of the responses to this question as a result. A similar question does not appear on the RADAR survey. As a result, alternate methods may be employed to estimate active and ongoing partnerships to derive the mean degree of individuals in the partnership network.
 
## Methods and Results

The ART-Net Survey asks study participants about the number of partners they have had in the past 12 months:

> In the past 12 months (since the same month last year), with how many different 
> men have you had either oral or anal sex?

The survey follows up with a question asking about the number of active, ongoing
sexual partnerships at the time of the survey among all partnerships that have occurred in the past 12 months:

> Next, think of all the men who you are in an active, ongoing sexual relationship 
> with. By that, we mean that you generally have oral or anal sex at least once per 
> month and you expect to continue doing so for some time. How many of your 
> partnerships in the past twelve months are active and ongoing?

As discussed in the description, mean degree can then be directly calculated from the responses to the above questions. 
I will refer to this as the **day-of-survey method**.

\newpage
Below is the code to calculate mean degree by partnership type - casual or main - using the day of survey method from the ART-net long and wide datasets. Note that the granularity of the ART-net long dataset is the individual partnerships whereas the granularity of the ART-net wide dataset is the surveyed individual. First, the number of ongoing partnerships per individual is assessed using the long dataset. Then, mean degree is calculated by summing ongoing partnerships by surveyed individual and dividing by total surveyed individuals using the wide dataset.

```{r load, include=FALSE}
library(knitr)
options(kableExtra.latex.load_packages = FALSE)
library(kableExtra)
library("tidyverse")
library("ARTnetData")
setwd("~/EpiModel Lab/ARTnet RADAR Mean Degree Comparison/ARTnet-RADAR/Analysis/Mean Degree Method Comparison")
```

```{r dos, warning=FALSE, include=FALSE}
##
## 02 - Network parameter analysis for ARTnet-RADAR Model
##

## Data ##
d <- ARTnet.wide
l <- ARTnet.long

## Inputs ##
city_name <- "Chicago"
coef_name <- paste0("city2", city_name)


# 0. Data Processing ------------------------------------------------------

## Degree calculations ##

l$ONGOING <- as.numeric(l$ONGOING)
l$ongoing2 <- ifelse(is.na(l$ONGOING), 0, l$ONGOING)
l$ONGOING <- NULL

d <- l %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(ptype == 1) %>%
  group_by(AMIS_ID) %>%
  summarise(deg.main = sum(ongoing2)) %>%
  right_join(d, by = "AMIS_ID")

d <- l %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(ptype == 2) %>%
  group_by(AMIS_ID) %>%
  summarise(deg.casl = sum(ongoing2)) %>%
  right_join(d, by = "AMIS_ID")

# If missing degree, then set to 0
d$deg.main <- ifelse(is.na(d$deg.main), 0, d$deg.main)
d$deg.casl <- ifelse(is.na(d$deg.casl), 0, d$deg.casl)

summary(d$deg.main)
summary(d$deg.casl)

# recoding to truncate degree
d$deg.casl <- ifelse(d$deg.casl > 3, 3, d$deg.casl)
d$deg.main <- ifelse(d$deg.main > 2, 2, d$deg.main)

d$deg.tot <- d$deg.main + d$deg.casl

md <- group_by(d, city2) %>%
  summarise(dm = mean(deg.main), dc = mean(deg.casl), dt = mean(deg.tot))
print(md, n = nrow(md))

round(prop.table(table(d$deg.main, d$deg.casl)), 3)

# Concurrency
d$deg.main.conc <- ifelse(d$deg.main > 1, 1, 0)
d$deg.casl.conc <- ifelse(d$deg.casl > 1, 1, 0)

## one-off calcs ##

# Total MC anal sex partner count
d <- l %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(ptype %in% 1:2) %>%
  group_by(AMIS_ID) %>%
  count() %>%
  rename(count.mc.part = n) %>%
  right_join(d, by = "AMIS_ID")
d$count.mc.part <- ifelse(is.na(d$count.mc.part), 0, d$count.mc.part)

d$count.oo.part <- d$ai.part - d$count.mc.part
d$count.oo.part <- pmax(0, d$count.oo.part)

head(data.frame(d$ai.part, d$count.mc.part, d$count.oo.part), 25)
summary(d$count.oo.part)

# Truncated OO part
d$count.oo.part.trunc <- ifelse(d$count.oo.part > 100, 100, d$count.oo.part)
summary(d$count.oo.part.trunc)
table(d$count.oo.part.trunc)


## Race/Ethnicity
table(d$race.cat)
d$race.cat3 <- rep(NA, nrow(d))
d$race.cat3[d$race.cat == "black"] <- 0
d$race.cat3[d$race.cat == "hispanic"] <- 1
d$race.cat3[d$race.cat %in% c("white", "other")] <- 2
table(d$race.cat, d$race.cat3)

table(l$race.cat, useNA = "always")
table(l$p_race.cat, useNA = "always")
table(l$race.cat, l$p_race.cat, useNA = "always")

l$race.cat3 <- rep(NA, nrow(l))
l$race.cat3[l$race.cat == "black"] <- 0
l$race.cat3[l$race.cat == "hispanic"] <- 1
l$race.cat3[l$race.cat %in% c("white", "other")] <- 2
table(l$race.cat3, useNA = "always")

table(l$p_race.cat, useNA = "always")
l$p_race.cat3 <- rep(NA, nrow(l))
l$p_race.cat3[l$p_race.cat == "black"] <- 0
l$p_race.cat3[l$p_race.cat == "hispanic"] <- 1
l$p_race.cat3[l$p_race.cat %in% c("white", "other")] <- 2
table(l$p_race.cat3, useNA = "always")

# redistribute NAs in proportion to non-missing partner races
probs <- prop.table(table(l$race.cat3, l$p_race.cat3), 1)

imp_black <- which(is.na(l$p_race.cat3) & l$race.cat3 == 0)
l$p_race.cat3[imp_black] <- sample(0:2, length(imp_black), TRUE, probs[1, ])

imp_hisp <- which(is.na(l$p_race.cat3) & l$race.cat3 == 1)
l$p_race.cat3[imp_hisp] <- sample(0:2, length(imp_hisp), TRUE, probs[2, ])

imp_white <- which(is.na(l$p_race.cat3) & l$race.cat3 == 2)
l$p_race.cat3[imp_white] <- sample(0:2, length(imp_white), TRUE, probs[3, ])

table(l$race.cat3, l$p_race.cat3, useNA = "always")


## HIV status

l$p_hiv2 <- ifelse(l$p_hiv == 1, 1, 0)
table(l$p_hiv, l$p_hiv2, useNA = "always")

hiv.combo <- rep(NA, nrow(l))
hiv.combo[l$hiv2 == 0 & l$p_hiv == 0] <- 1
hiv.combo[l$hiv2 == 1 & l$p_hiv == 1] <- 2
hiv.combo[l$hiv2 == 1 & l$p_hiv == 0] <- 3
hiv.combo[l$hiv2 == 0 & l$p_hiv == 1] <- 3
hiv.combo[l$hiv2 == 0 & l$p_hiv == 2] <- 4
hiv.combo[l$hiv2 == 1 & l$p_hiv == 2] <- 5
table(hiv.combo, useNA = "always")

l$hiv.concord <- ifelse(hiv.combo %in% 0:1, 1, 0)
l$hiv.concord.pos <- ifelse(hiv.combo == 2, 1, 0)
table(l$hiv.concord)
table(l$hiv.concord.pos)


# Age Filtering
l <- filter(l, age >= 16 & age <= 29)
nrow(l)

d <- filter(d, age >= 16 & age <= 29)
nrow(d)

## Setup output list ##

out_dos <- list()


# 1. Main model -----------------------------------------------------------

out_dos$main <- list()
lmain <- l[l$ptype == 1, ]


## 1A: edges ##

mod <- glm(deg.main ~ city2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$md.main <- as.numeric(pred)


## 1B: nodematch("age.grp", diff = TRUE) ##

age.breaks <- c(15, 18, 24, 29)
lmain$index.age.grp <- cut(lmain$age, age.breaks, labels = FALSE)
lmain$part.age.grp <- cut(as.numeric(lmain$p_age_imp), age.breaks, labels = FALSE)
data.frame(lmain$age, lmain$index.age.grp, lmain$p_age_imp, lmain$part.age.grp)

lmain$same.age.grp <- ifelse(lmain$index.age.grp == lmain$part.age.grp, 1, 0)

mod <- glm(same.age.grp ~ city2 + index.age.grp,
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, index.age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nm.age.grp <- as.numeric(pred)




## 1Bb: nodematch("age.grp", diff = FALSE) ##

mod <- glm(same.age.grp ~ city2,
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nm.age.grp_diffF <- as.numeric(pred)



## 1C: nodefactor("age.grp") ##

d$age.grp <- cut(d$age, age.breaks, labels = FALSE)

mod <- glm(deg.main ~ city2 + age.grp + sqrt(age.grp),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nf.age.grp <- as.numeric(pred)



## 1D: nodematch("race", diff = TRUE) ##

prop.table(table(lmain$race.cat3, lmain$p_race.cat3), 1)

lmain$same.race <- ifelse(lmain$race.cat3 == lmain$p_race.cat3, 1, 0)
group_by(lmain, race.cat3) %>%
  summarise(mn = mean(same.race))

mod <- glm(same.race ~ city2 + as.factor(race.cat3),
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nm.race <- as.numeric(pred)


## 1Db: nodematch("race", diff = FALSE) ##

mod <- glm(same.race ~ city2,
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nm.race_diffF <- as.numeric(pred)


## 1E: nodefactor("race") ##

mod <- glm(deg.main ~ city2 + as.factor(race.cat3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nf.race <- as.numeric(pred)



## 1F: nodefactor("deg.casl") ##

mod <- glm(deg.main ~ city2 + deg.casl,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, deg.casl = sort(unique(d$deg.casl)))
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nf.deg.casl <- as.numeric(pred)

deg.casl.dist <- prop.table(table(d$deg.casl[d$city2 == city_name]))
out_dos$main$deg.casl.dist <- as.numeric(deg.casl.dist)



## 1G: concurrent ##

mod <- glm(deg.main.conc ~ city2,
           data = d, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$concurrent <- as.numeric(pred)


## 1H: nodefactor("diag.status") ##

mod <- glm(deg.main ~ city2 + hiv2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, hiv2 = 0:1)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$main$nf.diag.status <- as.numeric(pred)



## Durations ##

# overall
durs.main <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing2 == 1) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# create city weights
durs.main.geo <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing2 == 1) %>%
  filter(city2 == city_name) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# city-specific weight based on ratio of medians
wt <- durs.main.geo$median.dur/durs.main$median.dur

# The weekly dissolution rate is function of the mean of the geometric distribution
# which relates to the median as:
durs.main$rates.main.adj <- 1 - (2^(-1/(wt*durs.main$median.dur)))

# Mean duration associated with a geometric distribution that median:
durs.main$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.main$median.dur))))
out_dos$main$durs.main.homog <- durs.main

# stratified by age

# first, non-matched by age group
durs.main.nonmatch <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing2 == 1) %>%
  filter(same.age.grp == 0) %>%
  # group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.main.nonmatch$index.age.grp <- 0

# then, matched within age-groups
durs.main.matched <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing2 == 1) %>%
  filter(same.age.grp == 1) %>%
  group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.main.matched

durs.main.all <- rbind(durs.main.nonmatch, durs.main.matched)

durs.main.all$rates.main.adj <- 1 - (2^(-1/(wt*durs.main.all$median.dur)))
durs.main.all$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.main.all$median.dur))))

durs.main.all <- durs.main.all[, c(3, 1, 2, 4, 5)]
out_dos$main$durs.main.byage <- durs.main.all



# 2. Casual model ---------------------------------------------------------

out_dos$casl <- list()
lcasl <- l[l$ptype == 2, ]


## 2A: edges ##

mod <- glm(deg.casl ~ city2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$md.casl <- as.numeric(pred)


## 2B: nodematch("age.grp", diff = TRUE) ##

lcasl$index.age.grp <- cut(lcasl$age, age.breaks, labels = FALSE)
lcasl$part.age.grp <- cut(as.numeric(lcasl$p_age_imp), age.breaks, labels = FALSE)
data.frame(lcasl$age, lcasl$index.age.grp, lcasl$p_age_imp, lcasl$part.age.grp)

lcasl$same.age.grp <- ifelse(lcasl$index.age.grp == lcasl$part.age.grp, 1, 0)

mod <- glm(same.age.grp ~ city2 + index.age.grp,
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, index.age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nm.age.grp <- as.numeric(pred)

# Consider adding absdiff within index.age.grp
# group_by(lcasl, index.age.grp) %>%
#   summarise(absdiff = mean(abs(age - p_age_imp)))
#
# abs(lcasl$age - lcasl$p_age_imp)


## 2B: nodematch("age.grp", diff = FALSE) ##

mod <- glm(same.age.grp ~ city2,
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nm.age.grp_diffF <- as.numeric(pred)


## 2C: nodefactor("age.grp") ##

d$age.grp <- cut(d$age, age.breaks, labels = FALSE)

mod <- glm(deg.casl ~ city2 + age.grp + sqrt(age.grp),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nf.age.grp <- as.numeric(pred)


## 2D: nodematch("race") ##

prop.table(table(lcasl$race.cat3, lcasl$p_race.cat3), 1)

lcasl$same.race <- ifelse(lcasl$race.cat3 == lcasl$p_race.cat3, 1, 0)

mod <- glm(same.race ~ city2 + as.factor(race.cat3),
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nm.race <- as.numeric(pred)


## 2Db: nodematch("race", diff = FALSE) ##

mod <- glm(same.race ~ city2,
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nm.race_diffF <- as.numeric(pred)


## 2E: nodefactor("race", diff = TRUE) ##

mod <- glm(deg.casl ~ city2 + as.factor(race.cat3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nf.race <- as.numeric(pred)


## 2F: nodefactor("deg.main") ##

mod <- glm(deg.casl ~ city2 + deg.main,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, deg.main = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nf.deg.main <- as.numeric(pred)

deg.main.dist <- prop.table(table(d$deg.main[d$city2 == city_name]))
out_dos$casl$deg.main.dist <- as.numeric(deg.main.dist)


## 2G: concurrent ##

mod <- glm(deg.casl.conc ~ city2,
           data = d, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$concurrent <- as.numeric(pred)


## 2H: nodefactor("diag.status") ##

mod <- glm(deg.casl ~ city2 + hiv2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, hiv2 = 0:1)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$casl$nf.diag.status <- as.numeric(pred)


## Durations ##

# overall
durs.casl <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing2 == 1) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# create city weights
durs.casl.geo <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing2 == 1) %>%
  filter(city2 == city_name) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# city-specific weight based on ratio of medians
wt <- durs.casl.geo$median.dur/durs.casl$median.dur

# The weekly dissolution rate is function of the mean of the geometric distribution
# which relates to the median as:
durs.casl$rates.casl.adj <- 1 - (2^(-1/(wt*durs.casl$median.dur)))

# Mean duration associated with a geometric distribution that median:
durs.casl$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.casl$median.dur))))
out_dos$casl$durs.casl.homog <- durs.casl

# stratified by age

# first, non-matched by age group
durs.casl.nonmatch <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing2 == 1) %>%
  filter(same.age.grp == 0) %>%
  # group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.casl.nonmatch$index.age.grp <- 0

# then, matched within age-groups
durs.casl.matched <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(same.age.grp == 1) %>%
  filter(ongoing2 == 1) %>%
  group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.casl.matched

durs.casl.all <- rbind(durs.casl.nonmatch, durs.casl.matched)
durs.casl.all

durs.casl.all$rates.casl.adj <- 1 - (2^(-1/(wt*durs.casl.all$median.dur)))
durs.casl.all$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.casl.all$median.dur))))

durs.casl.all <- durs.casl.all[, c(3, 1, 2, 4, 5)]
out_dos$casl$durs.casl.byage <- durs.casl.all


# 3. One-off model --------------------------------------------------------

out_dos$inst <- list()
linst <- l[l$ptype == 3, ]

## 3A: edges ##

head(d$count.oo.part, 25)
summary(d$count.oo.part)

# weekly rate
d$rate.oo.part <- d$count.oo.part/52
summary(d$rate.oo.part)

mod <- glm(count.oo.part ~ city2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")/52

out_dos$inst$md.inst <- as.numeric(pred)


## 3B: nodematch("age.grp", diff = TRUE) ##

linst$index.age.grp <- cut(linst$age, age.breaks, labels = FALSE)
linst$part.age.grp <- cut(as.numeric(linst$p_age_imp), age.breaks, labels = FALSE)
data.frame(linst$age, linst$index.age.grp, linst$p_age_imp, linst$part.age.grp)

linst$same.age.grp <- ifelse(linst$index.age.grp == linst$part.age.grp, 1, 0)

mod <- glm(same.age.grp ~ city2 + index.age.grp,
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, index.age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$inst$nm.age.grp <- as.numeric(pred)


## 3Bb: nodematch("age.grp", diff = FALSE) ##

mod <- glm(same.age.grp ~ city2,
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$inst$nm.age.grp_diffF <- as.numeric(pred)


## 3C: nodefactor("age.grp") ##

d$age.grp <- cut(d$age, age.breaks, labels = FALSE)

mod <- glm(count.oo.part ~ city2 + age.grp + sqrt(age.grp),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")/52

out_dos$inst$nf.age.grp <- as.numeric(pred)


## 3D: nodematch("race", diff = TRUE) ##

prop.table(table(linst$race.cat3, linst$p_race.cat3), 1)

linst$same.race <- ifelse(linst$race.cat3 == linst$p_race.cat3, 1, 0)

mod <- glm(same.race ~ city2 + as.factor(race.cat3),
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$inst$nm.race <- as.numeric(pred)


## 3D: nodematch("race", diff = FALSE) ##

mod <- glm(same.race ~ city2,
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out_dos$inst$nm.race_diffF <- as.numeric(pred)


## 3E: nodefactor("race") ##

mod <- glm(count.oo.part ~ city2 + as.factor(race.cat3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")/52

out_dos$inst$nf.race <- as.numeric(pred)


## 3F: nodefactor("risk.grp") ##

# city-specific wts
wt <- mean(d$rate.oo.part[d$city2 == city_name], na.rm = TRUE)/mean(d$rate.oo.part, na.rm = TRUE)
wt.rate <- d$rate.oo.part * wt

oo.quants <- rep(NA, 5)
sr <- sort(wt.rate)
qsize <- floor(length(sr) / 5)
oo.quants[1] <- mean(sr[1:qsize])
oo.quants[2] <- mean(sr[((1*qsize)+1):(2*qsize)])
oo.quants[3] <- mean(sr[((2*qsize)+1):(3*qsize)])
oo.quants[4] <- mean(sr[((3*qsize)+1):(4*qsize)])
oo.quants[5] <- mean(sr[((4*qsize)+1):length(sr)])

# Weekly acquisition rate
oo.quants

# Yearly OO partner count
oo.quants * 52

# New OO partner every X years
1/(oo.quants * 52)

# New OO partner every weeks
1/oo.quants

# Save it
out_dos$inst$nf.risk.grp <- oo.quants


## 3G: nodefactor("deg.tot") ##

d$deg.tot3 <- ifelse(d$deg.tot >= 3, 3, d$deg.tot)
table(d$deg.tot3)

deg.tot.dist <- prop.table(table(d$deg.tot3[d$city2 == city_name]))
out_dos$inst$deg.tot.dist <- as.numeric(deg.tot.dist)

mod <- glm(count.oo.part ~ city2 + deg.tot3 + sqrt(deg.tot3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, deg.tot3 = 0:3)
pred <- predict(mod, newdata = dat, type = "response")/52

out_dos$inst$nf.deg.tot <- as.numeric(pred)


## 3H: nodefactor("diag.status") ##

mod <- glm(count.oo.part ~ city2 + hiv2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, hiv2 = 0:1)
pred <- predict(mod, newdata = dat, type = "response")/52

out_dos$inst$nf.diag.status <- as.numeric(pred)



# 4. Other Parameters -----------------------------------------------------

## Sexual Role ##

d <- l %>%
  filter(RAI == 1) %>%
  group_by(AMIS_ID) %>%
  count() %>%
  rename(nRAIpart = n) %>%
  right_join(d, by = "AMIS_ID") %>%
  as.data.frame()
d$nRAIpart <- ifelse(is.na(d$nRAIpart), 0, d$nRAIpart)
table(d$nRAIpart, useNA = "always")

d <- l %>%
  filter(IAI == 1) %>%
  group_by(AMIS_ID) %>%
  count() %>%
  rename(nIAIpart = n) %>%
  right_join(d, by = "AMIS_ID") %>%
  as.data.frame()
d$nIAIpart <- ifelse(is.na(d$nIAIpart), 0, d$nIAIpart)
table(d$nIAIpart, useNA = "always")

table(d$nRAIpart, d$nIAIpart, useNA = "always")

# default NA for no AI
roletype <- rep(NA, nrow(d))
roletype[d$nRAIpart == 0 & d$nIAIpart > 0] <- 0
roletype[d$nIAIpart == 0 & d$nRAIpart > 0] <- 1
roletype[d$nIAIpart > 0 & d$nRAIpart > 0] <- 2
table(roletype, useNA = "always")

out_dos$all$role.type <- prop.table(table(roletype))



# SAVE --------------------------------------------------------------------

# fn <- paste("ARTnetWorkflow/data/artnet.NetParam", gsub(" ", "", city_name), "rda", sep = ".")
# saveRDS(out, file = fn)



#####################################################

## OUTPUTS

## Mean Degree

# Overall
md.overall.main.ARTnet_DOS_script <- out_dos$main$md.main
md.overall.casl.ARTnet_DOS_script <- out_dos$casl$md.casl
md.overall.inst.ARTnet_DOS_script <- out_dos$inst$md.inst

# By Age Group
md.age.main.ARTnet_DOS_script <- out_dos$main$nf.age.grp
md.age.casl.ARTnet_DOS_script <- out_dos$casl$nf.age.grp
md.age.inst.ARTnet_DOS_script <- out_dos$inst$nf.age.grp

# By Race
md.race.main.ARTnet_DOS_script <- out_dos$main$nf.race
md.race.casl.ARTnet_DOS_script <- out_dos$casl$nf.race
md.race.inst.ARTnet_DOS_script <- out_dos$inst$nf.race

# By Diagnosed HIV Status
md.HIV_status.main.ARTnet_DOS_script <- out_dos$main$nf.diag.status
md.HIV_status.casl.ARTnet_DOS_script <- out_dos$casl$nf.diag.status
md.HIV_status.inst.ARTnet_DOS_script <- out_dos$inst$nf.diag.status

# By Cross Partnership Degree
md.casl_cross_deg.main.ARTnet_DOS_script <- out_dos$main$nf.deg.casl
md.main_cross_deg.casl.ARTnet_DOS_script <- out_dos$casl$nf.deg.main


## Proportion Concurrent
prop.concurrent.main.ARTnet_DOS_script <- out_dos$main$concurrent
prop.concurrent.casl.ARTnet_DOS_script <- out_dos$casl$concurrent


## Mixing

# By Age - Overall
mixing.age.overall.main.ARTnet_DOS_script <- out_dos$main$nm.age.grp_diffF
mixing.age.overall.casl.ARTnet_DOS_script <- out_dos$casl$nm.age.grp_diffF
mixing.age.overall.inst.ARTnet_DOS_script <- out_dos$inst$nm.age.grp_diffF

# By Age - Within Age Group
mixing.age.within_group.main.ARTnet_DOS_script <- out_dos$main$nm.age.grp
mixing.age.within_group.casl.ARTnet_DOS_script <- out_dos$casl$nm.age.grp
mixing.age.within_group.inst.ARTnet_DOS_script <- out_dos$inst$nm.age.grp

# By Race - Overall
mixing.race.overall.main.ARTnet_DOS_script <- out_dos$main$nm.race_diffF
mixing.race.overall.casl.ARTnet_DOS_script <- out_dos$casl$nm.race_diffF
mixing.race.overall.inst.ARTnet_DOS_script <- out_dos$inst$nm.race_diffF

# By Race - Within Race Group
mixing.race.within_group.main.ARTnet_DOS_script <- out_dos$main$nm.race
mixing.race.within_group.casl.ARTnet_DOS_script <- out_dos$casl$nm.race
mixing.race.within_group.inst.ARTnet_DOS_script <- out_dos$inst$nm.race


## Mean Duration
duration.main.ARTnet_DOS_script <- durs.main.all$mean.dur.adj
duration.casl.ARTnet_DOS_script <- durs.casl.all$mean.dur.adj


## One-Time Partner Rates 

# By Main+Casual Degree
OTP.rates.by.degree.ARTnet_DOS_script <- out_dos$inst$nf.deg.tot

# By Risk Quintile
OTP.rates.by.risk.ARTnet_DOS_script <- out_dos$inst$nf.risk.grp
```

Using the day-of-survey method, the mean degree of main partnerships among individuals in the ART-net dataset is
```{r tessst, echo=FALSE}
round(out_dos$main$md.main,4)
```

```{r dos_results, echo=FALSE}
cat("Using the day-of-survey method, the mean degree of main partnerships\n among individuals in the ART-net dataset is: ", round(out_dos$main$md.main,4))

cat("Using the day-of-survey method, the mean degree of casual partnerships\n among individuals in the ART-net dataset is: ", round(out_dos$casl$md.casl,4))
```

\newpage
In contrast, an alternate approach referred to as the **three-month offset method**, for deriving active and ongoing partnerships may also be used in the instance where individuals are not explicitly asked about number of active and ongoing partners at the time of the survey. 

The three-month offset method starts by taking a three-month offset of the survey date. For example, if an individual was surveyed July 15th 2019, then their three-month offset would be April 15th 2019. Once this offset is established for all surveyed individuals, each individual partership is assessed to determine if the three-month offset falls between the start and end date of the partnership. If the three-month offset falls between the partership start and end date, then the partnership is considered active and ongoing; otherwise, it is not considered active and ongoing.

![Three-Month Offset Method Data Scenario](Mean Degree of Ongoing Partnerships - Three-Month Offset Method Data Scenario.png)
\newpage


```{r n_month, warning=FALSE, include=FALSE}
##
## 02 - Network parameter analysis for ARTnet-RADAR Model - N Month Offset
##

## Packages ##
library("tidyverse")
library("ARTnetData")

out_list <- list()

md.overall.main.ARTnet_N_MO_script <- list()
md.overall.casl.ARTnet_N_MO_script <- list()
md.overall.inst.ARTnet_N_MO_script <- list()
md.age.main.ARTnet_N_MO_script <- list()
md.age.casl.ARTnet_N_MO_script <- list()
md.age.inst.ARTnet_N_MO_script <- list()
md.race.main.ARTnet_N_MO_script <- list()
md.race.casl.ARTnet_N_MO_script <- list()
md.race.inst.ARTnet_N_MO_script <- list()
md.HIV_status.main.ARTnet_N_MO_script <- list()
md.HIV_status.casl.ARTnet_N_MO_script <- list()
md.HIV_status.inst.ARTnet_N_MO_script <- list()
md.casl_cross_deg.main.ARTnet_N_MO_script <- list()
md.main_cross_deg.casl.ARTnet_N_MO_script <- list()
prop.concurrent.main.ARTnet_N_MO_script <- list()
prop.concurrent.casl.ARTnet_N_MO_script <- list()
mixing.age.overall.main.ARTnet_N_MO_script <- list()
mixing.age.overall.casl.ARTnet_N_MO_script <- list()
mixing.age.overall.inst.ARTnet_N_MO_script <- list()
mixing.age.within_group.main.ARTnet_N_MO_script <- list()
mixing.age.within_group.casl.ARTnet_N_MO_script <- list()
mixing.age.within_group.inst.ARTnet_N_MO_script <- list()
mixing.race.overall.main.ARTnet_N_MO_script <- list()
mixing.race.overall.casl.ARTnet_N_MO_script <- list()
mixing.race.overall.inst.ARTnet_N_MO_script <- list()
mixing.race.within_group.main.ARTnet_N_MO_script <- list()
mixing.race.within_group.casl.ARTnet_N_MO_script <- list()
mixing.race.within_group.inst.ARTnet_N_MO_script <- list()
duration.main.ARTnet_N_MO_script <- list()
duration.casl.ARTnet_N_MO_script <- list()
OTP.rates.by.degree.ARTnet_N_MO_script <- list()
OTP.rates.by.risk.ARTnet_N_MO_script <- list()

for (i in 1:13) {

  ## Data ##
  d <- ARTnet.wide
  l <- ARTnet.long
  
  ## Inputs ##
  city_name <- "Chicago"
  coef_name <- paste0("city2", city_name)
  
  
  # 0. Data Processing ------------------------------------------------------
  
  ## Degree calculations ##
  
  l$ONGOING <- as.numeric(l$ONGOING)
  l$ongoing2 <- ifelse(is.na(l$ONGOING), 0, l$ONGOING)
  
prior.month.of.evaluation <- i-1
ARTnet.long$ongoing.evaluation.date <- ARTnet.long$SUB_DATE -
  round(prior.month.of.evaluation*30.44)
l$ongoing3 <- ifelse(ARTnet.long$start.date <
                       ARTnet.long$ongoing.evaluation.date &
                       ARTnet.long$end.date + 1 >
                       ARTnet.long$ongoing.evaluation.date, 1, 0)
l$ONGOING <- NULL

d <- l %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(ptype == 1) %>%
  group_by(AMIS_ID) %>%
  summarise(deg.main = sum(ongoing3)) %>%
  right_join(d, by = "AMIS_ID")

d <- l %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(ptype == 2) %>%
  group_by(AMIS_ID) %>%
  summarise(deg.casl = sum(ongoing3)) %>%
  right_join(d, by = "AMIS_ID")

# If missing degree, then set to 0
d$deg.main <- ifelse(is.na(d$deg.main), 0, d$deg.main)
d$deg.casl <- ifelse(is.na(d$deg.casl), 0, d$deg.casl)

summary(d$deg.main)
summary(d$deg.casl)

# recoding to truncate degree
d$deg.casl <- ifelse(d$deg.casl > 3, 3, d$deg.casl)
d$deg.main <- ifelse(d$deg.main > 2, 2, d$deg.main)

d$deg.tot <- d$deg.main + d$deg.casl

md <- group_by(d, city2) %>%
  summarise(dm = mean(deg.main), dc = mean(deg.casl), dt = mean(deg.tot))
print(md, n = nrow(md))

round(prop.table(table(d$deg.main, d$deg.casl)), 3)

# Concurrency
d$deg.main.conc <- ifelse(d$deg.main > 1, 1, 0)
d$deg.casl.conc <- ifelse(d$deg.casl > 1, 1, 0)

## one-off calcs ##

# Total MC anal sex partner count
d <- l %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(ptype %in% 1:2) %>%
  group_by(AMIS_ID) %>%
  count() %>%
  rename(count.mc.part = n) %>%
  right_join(d, by = "AMIS_ID")
d$count.mc.part <- ifelse(is.na(d$count.mc.part), 0, d$count.mc.part)

d$count.oo.part <- d$ai.part - d$count.mc.part
d$count.oo.part <- pmax(0, d$count.oo.part)

head(data.frame(d$ai.part, d$count.mc.part, d$count.oo.part), 25)
summary(d$count.oo.part)

# Truncated OO part
d$count.oo.part.trunc <- ifelse(d$count.oo.part > 100, 100, d$count.oo.part)
summary(d$count.oo.part.trunc)
table(d$count.oo.part.trunc)


## Race/Ethnicity
table(d$race.cat)
d$race.cat3 <- rep(NA, nrow(d))
d$race.cat3[d$race.cat == "black"] <- 0
d$race.cat3[d$race.cat == "hispanic"] <- 1
d$race.cat3[d$race.cat %in% c("white", "other")] <- 2
table(d$race.cat, d$race.cat3)

table(l$race.cat, useNA = "always")
table(l$p_race.cat, useNA = "always")
table(l$race.cat, l$p_race.cat, useNA = "always")

l$race.cat3 <- rep(NA, nrow(l))
l$race.cat3[l$race.cat == "black"] <- 0
l$race.cat3[l$race.cat == "hispanic"] <- 1
l$race.cat3[l$race.cat %in% c("white", "other")] <- 2
table(l$race.cat3, useNA = "always")

table(l$p_race.cat, useNA = "always")
l$p_race.cat3 <- rep(NA, nrow(l))
l$p_race.cat3[l$p_race.cat == "black"] <- 0
l$p_race.cat3[l$p_race.cat == "hispanic"] <- 1
l$p_race.cat3[l$p_race.cat %in% c("white", "other")] <- 2
table(l$p_race.cat3, useNA = "always")

# redistribute NAs in proportion to non-missing partner races
probs <- prop.table(table(l$race.cat3, l$p_race.cat3), 1)

imp_black <- which(is.na(l$p_race.cat3) & l$race.cat3 == 0)
l$p_race.cat3[imp_black] <- sample(0:2, length(imp_black), TRUE, probs[1, ])

imp_hisp <- which(is.na(l$p_race.cat3) & l$race.cat3 == 1)
l$p_race.cat3[imp_hisp] <- sample(0:2, length(imp_hisp), TRUE, probs[2, ])

imp_white <- which(is.na(l$p_race.cat3) & l$race.cat3 == 2)
l$p_race.cat3[imp_white] <- sample(0:2, length(imp_white), TRUE, probs[3, ])

table(l$race.cat3, l$p_race.cat3, useNA = "always")


## HIV status

l$p_hiv2 <- ifelse(l$p_hiv == 1, 1, 0)
table(l$p_hiv, l$p_hiv2, useNA = "always")

hiv.combo <- rep(NA, nrow(l))
hiv.combo[l$hiv2 == 0 & l$p_hiv == 0] <- 1
hiv.combo[l$hiv2 == 1 & l$p_hiv == 1] <- 2
hiv.combo[l$hiv2 == 1 & l$p_hiv == 0] <- 3
hiv.combo[l$hiv2 == 0 & l$p_hiv == 1] <- 3
hiv.combo[l$hiv2 == 0 & l$p_hiv == 2] <- 4
hiv.combo[l$hiv2 == 1 & l$p_hiv == 2] <- 5
table(hiv.combo, useNA = "always")

l$hiv.concord <- ifelse(hiv.combo %in% 0:1, 1, 0)
l$hiv.concord.pos <- ifelse(hiv.combo == 2, 1, 0)
table(l$hiv.concord)
table(l$hiv.concord.pos)

# Age Filtering
l <- filter(l, age >= 16 & age <= 29)
nrow(l)

d <- filter(d, age >= 16 & age <= 29)
nrow(d)

## Setup output list ##

out <- list()


# 1. Main model -----------------------------------------------------------

out$main <- list()
lmain <- l[l$ptype == 1, ]


## 1A: edges ##

mod <- glm(deg.main ~ city2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$main$md.main <- as.numeric(pred)


## 1B: nodematch("age.grp", diff = TRUE) ##

age.breaks <- c(15, 18, 24, 29)
lmain$index.age.grp <- cut(lmain$age, age.breaks, labels = FALSE)
lmain$part.age.grp <- cut(as.numeric(lmain$p_age_imp), age.breaks, labels = FALSE)
data.frame(lmain$age, lmain$index.age.grp, lmain$p_age_imp, lmain$part.age.grp)

lmain$same.age.grp <- ifelse(lmain$index.age.grp == lmain$part.age.grp, 1, 0)

mod <- glm(same.age.grp ~ city2 + index.age.grp,
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, index.age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out$main$nm.age.grp <- as.numeric(pred)




## 1Bb: nodematch("age.grp", diff = FALSE) ##

mod <- glm(same.age.grp ~ city2,
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$main$nm.age.grp_diffF <- as.numeric(pred)



## 1C: nodefactor("age.grp") ##

d$age.grp <- cut(d$age, age.breaks, labels = FALSE)

mod <- glm(deg.main ~ city2 + age.grp + sqrt(age.grp),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out$main$nf.age.grp <- as.numeric(pred)



## 1D: nodematch("race", diff = TRUE) ##

prop.table(table(lmain$race.cat3, lmain$p_race.cat3), 1)

lmain$same.race <- ifelse(lmain$race.cat3 == lmain$p_race.cat3, 1, 0)
group_by(lmain, race.cat3) %>%
  summarise(mn = mean(same.race))

mod <- glm(same.race ~ city2 + as.factor(race.cat3),
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out$main$nm.race <- as.numeric(pred)


## 1Db: nodematch("race", diff = FALSE) ##

mod <- glm(same.race ~ city2,
           data = lmain, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$main$nm.race_diffF <- as.numeric(pred)


## 1E: nodefactor("race") ##

mod <- glm(deg.main ~ city2 + as.factor(race.cat3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out$main$nf.race <- as.numeric(pred)



## 1F: nodefactor("deg.casl") ##

mod <- glm(deg.main ~ city2 + deg.casl,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, deg.casl = sort(unique(d$deg.casl)))
pred <- predict(mod, newdata = dat, type = "response")

out$main$nf.deg.casl <- as.numeric(pred)

deg.casl.dist <- prop.table(table(d$deg.casl[d$city2 == city_name]))
out$main$deg.casl.dist <- as.numeric(deg.casl.dist)



## 1G: concurrent ##

mod <- glm(deg.main.conc ~ city2,
           data = d, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$main$concurrent <- as.numeric(pred)


## 1H: nodefactor("diag.status") ##

mod <- glm(deg.main ~ city2 + hiv2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, hiv2 = 0:1)
pred <- predict(mod, newdata = dat, type = "response")

out$main$nf.diag.status <- as.numeric(pred)



## Durations ##

# overall
durs.main <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing3 == 1) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# create city weights
durs.main.geo <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing3 == 1) %>%
  filter(city2 == city_name) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# city-specific weight based on ratio of medians
wt <- durs.main.geo$median.dur/durs.main$median.dur

# The weekly dissolution rate is function of the mean of the geometric distribution
# which relates to the median as:
durs.main$rates.main.adj <- 1 - (2^(-1/(wt*durs.main$median.dur)))

# Mean duration associated with a geometric distribution that median:
durs.main$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.main$median.dur))))
out$main$durs.main.homog <- durs.main

# stratified by age

# first, non-matched by age group
durs.main.nonmatch <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing3 == 1) %>%
  filter(same.age.grp == 0) %>%
  # group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.main.nonmatch$index.age.grp <- 0

# then, matched within age-groups
durs.main.matched <- lmain %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing3 == 1) %>%
  filter(same.age.grp == 1) %>%
  group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.main.matched

durs.main.all <- rbind(durs.main.nonmatch, durs.main.matched)

durs.main.all$rates.main.adj <- 1 - (2^(-1/(wt*durs.main.all$median.dur)))
durs.main.all$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.main.all$median.dur))))

durs.main.all <- durs.main.all[, c(3, 1, 2, 4, 5)]
out$main$durs.main.byage <- durs.main.all



# 2. Casual model ---------------------------------------------------------

out$casl <- list()
lcasl <- l[l$ptype == 2, ]


## 2A: edges ##

mod <- glm(deg.casl ~ city2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$md.casl <- as.numeric(pred)


## 2B: nodematch("age.grp", diff = TRUE) ##

lcasl$index.age.grp <- cut(lcasl$age, age.breaks, labels = FALSE)
lcasl$part.age.grp <- cut(as.numeric(lcasl$p_age_imp), age.breaks, labels = FALSE)
data.frame(lcasl$age, lcasl$index.age.grp, lcasl$p_age_imp, lcasl$part.age.grp)

lcasl$same.age.grp <- ifelse(lcasl$index.age.grp == lcasl$part.age.grp, 1, 0)

mod <- glm(same.age.grp ~ city2 + index.age.grp,
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, index.age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nm.age.grp <- as.numeric(pred)

# Consider adding absdiff within index.age.grp
# group_by(lcasl, index.age.grp) %>%
#   summarise(absdiff = mean(abs(age - p_age_imp)))
#
# abs(lcasl$age - lcasl$p_age_imp)


## 2B: nodematch("age.grp", diff = FALSE) ##

mod <- glm(same.age.grp ~ city2,
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nm.age.grp_diffF <- as.numeric(pred)


## 2C: nodefactor("age.grp") ##

d$age.grp <- cut(d$age, age.breaks, labels = FALSE)

mod <- glm(deg.casl ~ city2 + age.grp + sqrt(age.grp),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nf.age.grp <- as.numeric(pred)


## 2D: nodematch("race") ##

prop.table(table(lcasl$race.cat3, lcasl$p_race.cat3), 1)

lcasl$same.race <- ifelse(lcasl$race.cat3 == lcasl$p_race.cat3, 1, 0)

mod <- glm(same.race ~ city2 + as.factor(race.cat3),
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nm.race <- as.numeric(pred)


## 2Db: nodematch("race", diff = FALSE) ##

mod <- glm(same.race ~ city2,
           data = lcasl, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nm.race_diffF <- as.numeric(pred)


## 2E: nodefactor("race", diff = TRUE) ##

mod <- glm(deg.casl ~ city2 + as.factor(race.cat3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nf.race <- as.numeric(pred)


## 2F: nodefactor("deg.main") ##

mod <- glm(deg.casl ~ city2 + deg.main,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, deg.main = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nf.deg.main <- as.numeric(pred)

deg.main.dist <- prop.table(table(d$deg.main[d$city2 == city_name]))
out$casl$deg.main.dist <- as.numeric(deg.main.dist)


## 2G: concurrent ##

mod <- glm(deg.casl.conc ~ city2,
           data = d, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$concurrent <- as.numeric(pred)


## 2H: nodefactor("diag.status") ##

mod <- glm(deg.casl ~ city2 + hiv2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, hiv2 = 0:1)
pred <- predict(mod, newdata = dat, type = "response")

out$casl$nf.diag.status <- as.numeric(pred)


## Durations ##

# overall
durs.casl <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing3 == 1) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# create city weights
durs.casl.geo <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing3 == 1) %>%
  filter(city2 == city_name) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()

# city-specific weight based on ratio of medians
wt <- durs.casl.geo$median.dur/durs.casl$median.dur

# The weekly dissolution rate is function of the mean of the geometric distribution
# which relates to the median as:
durs.casl$rates.casl.adj <- 1 - (2^(-1/(wt*durs.casl$median.dur)))

# Mean duration associated with a geometric distribution that median:
durs.casl$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.casl$median.dur))))
out$casl$durs.casl.homog <- durs.casl

# stratified by age

# first, non-matched by age group
durs.casl.nonmatch <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(ongoing3 == 1) %>%
  filter(same.age.grp == 0) %>%
  # group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.casl.nonmatch$index.age.grp <- 0

# then, matched within age-groups
durs.casl.matched <- lcasl %>%
  filter(RAI == 1 | IAI == 1) %>%
  filter(index.age.grp < 4) %>%
  filter(same.age.grp == 1) %>%
  filter(ongoing3 == 1) %>%
  group_by(index.age.grp) %>%
  summarise(mean.dur = mean(duration, na.rm = TRUE),
            median.dur = median(duration, na.rm = TRUE)) %>%
  as.data.frame()
durs.casl.matched

durs.casl.all <- rbind(durs.casl.nonmatch, durs.casl.matched)
durs.casl.all

durs.casl.all$rates.casl.adj <- 1 - (2^(-1/(wt*durs.casl.all$median.dur)))
durs.casl.all$mean.dur.adj <- 1/(1 - (2^(-1/(wt*durs.casl.all$median.dur))))

durs.casl.all <- durs.casl.all[, c(3, 1, 2, 4, 5)]
out$casl$durs.casl.byage <- durs.casl.all


# 3. One-off model --------------------------------------------------------

out$inst <- list()
linst <- l[l$ptype == 3, ]

## 3A: edges ##

head(d$count.oo.part, 25)
summary(d$count.oo.part)

# weekly rate
d$rate.oo.part <- d$count.oo.part/52
summary(d$rate.oo.part)

mod <- glm(count.oo.part ~ city2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")/52

out$inst$md.inst <- as.numeric(pred)


## 3B: nodematch("age.grp", diff = TRUE) ##

linst$index.age.grp <- cut(linst$age, age.breaks, labels = FALSE)
linst$part.age.grp <- cut(as.numeric(linst$p_age_imp), age.breaks, labels = FALSE)
data.frame(linst$age, linst$index.age.grp, linst$p_age_imp, linst$part.age.grp)

linst$same.age.grp <- ifelse(linst$index.age.grp == linst$part.age.grp, 1, 0)

mod <- glm(same.age.grp ~ city2 + index.age.grp,
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, index.age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")

out$inst$nm.age.grp <- as.numeric(pred)


## 3Bb: nodematch("age.grp", diff = FALSE) ##

mod <- glm(same.age.grp ~ city2,
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$inst$nm.age.grp_diffF <- as.numeric(pred)


## 3C: nodefactor("age.grp") ##

d$age.grp <- cut(d$age, age.breaks, labels = FALSE)

mod <- glm(count.oo.part ~ city2 + age.grp + sqrt(age.grp),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, age.grp = 1:3)
pred <- predict(mod, newdata = dat, type = "response")/52

out$inst$nf.age.grp <- as.numeric(pred)


## 3D: nodematch("race", diff = TRUE) ##

prop.table(table(linst$race.cat3, linst$p_race.cat3), 1)

linst$same.race <- ifelse(linst$race.cat3 == linst$p_race.cat3, 1, 0)

mod <- glm(same.race ~ city2 + as.factor(race.cat3),
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")

out$inst$nm.race <- as.numeric(pred)


## 3D: nodematch("race", diff = FALSE) ##

mod <- glm(same.race ~ city2,
           data = linst, family = binomial())
summary(mod)

dat <- data.frame(city2 = city_name)
pred <- predict(mod, newdata = dat, type = "response")

out$inst$nm.race_diffF <- as.numeric(pred)


## 3E: nodefactor("race") ##

mod <- glm(count.oo.part ~ city2 + as.factor(race.cat3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, race.cat3 = 0:2)
pred <- predict(mod, newdata = dat, type = "response")/52

out$inst$nf.race <- as.numeric(pred)


## 3F: nodefactor("risk.grp") ##

# city-specific wts
wt <- mean(d$rate.oo.part[d$city2 == city_name], na.rm = TRUE)/mean(d$rate.oo.part, na.rm = TRUE)
wt.rate <- d$rate.oo.part * wt

oo.quants <- rep(NA, 5)
sr <- sort(wt.rate)
qsize <- floor(length(sr) / 5)
oo.quants[1] <- mean(sr[1:qsize])
oo.quants[2] <- mean(sr[((1*qsize)+1):(2*qsize)])
oo.quants[3] <- mean(sr[((2*qsize)+1):(3*qsize)])
oo.quants[4] <- mean(sr[((3*qsize)+1):(4*qsize)])
oo.quants[5] <- mean(sr[((4*qsize)+1):length(sr)])

# Weekly acquisition rate
oo.quants

# Yearly OO partner count
oo.quants * 52

# New OO partner every X years
1/(oo.quants * 52)

# New OO partner every weeks
1/oo.quants

# Save it
out$inst$nf.risk.grp <- oo.quants


## 3G: nodefactor("deg.tot") ##

d$deg.tot3 <- ifelse(d$deg.tot >= 3, 3, d$deg.tot)
table(d$deg.tot3)

deg.tot.dist <- prop.table(table(d$deg.tot3[d$city2 == city_name]))
out$inst$deg.tot.dist <- as.numeric(deg.tot.dist)

mod <- glm(count.oo.part ~ city2 + deg.tot3 + sqrt(deg.tot3),
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, deg.tot3 = 0:3)
pred <- predict(mod, newdata = dat, type = "response")/52

out$inst$nf.deg.tot <- as.numeric(pred)


## 3H: nodefactor("diag.status") ##

mod <- glm(count.oo.part ~ city2 + hiv2,
           data = d, family = poisson())
summary(mod)

dat <- data.frame(city2 = city_name, hiv2 = 0:1)
pred <- predict(mod, newdata = dat, type = "response")/52

out$inst$nf.diag.status <- as.numeric(pred)



# 4. Other Parameters -----------------------------------------------------

## Sexual Role ##

d <- l %>%
  filter(RAI == 1) %>%
  group_by(AMIS_ID) %>%
  count() %>%
  rename(nRAIpart = n) %>%
  right_join(d, by = "AMIS_ID") %>%
  as.data.frame()
d$nRAIpart <- ifelse(is.na(d$nRAIpart), 0, d$nRAIpart)
table(d$nRAIpart, useNA = "always")

d <- l %>%
  filter(IAI == 1) %>%
  group_by(AMIS_ID) %>%
  count() %>%
  rename(nIAIpart = n) %>%
  right_join(d, by = "AMIS_ID") %>%
  as.data.frame()
d$nIAIpart <- ifelse(is.na(d$nIAIpart), 0, d$nIAIpart)
table(d$nIAIpart, useNA = "always")

table(d$nRAIpart, d$nIAIpart, useNA = "always")

# default NA for no AI
roletype <- rep(NA, nrow(d))
roletype[d$nRAIpart == 0 & d$nIAIpart > 0] <- 0
roletype[d$nIAIpart == 0 & d$nRAIpart > 0] <- 1
roletype[d$nIAIpart > 0 & d$nRAIpart > 0] <- 2
table(roletype, useNA = "always")

out$all$role.type <- prop.table(table(roletype))

out_list[[i]] <- out

# SAVE --------------------------------------------------------------------

# fn <- paste("ARTnetWorkflow/data/artnet.NetParam", gsub(" ", "", city_name), "rda", sep = ".")
# saveRDS(out, file = fn)

#####################################################

## OUTPUTS

## Mean Degree

# Overall
md.overall.main.ARTnet_N_MO_script[[i]] <- out$main$md.main
md.overall.casl.ARTnet_N_MO_script[[i]] <- out$casl$md.casl
md.overall.inst.ARTnet_N_MO_script[[i]] <- out$inst$md.inst

# By Age Group
md.age.main.ARTnet_N_MO_script[[i]] <- out$main$nf.age.grp
md.age.casl.ARTnet_N_MO_script[[i]] <- out$casl$nf.age.grp
md.age.inst.ARTnet_N_MO_script[[i]] <- out$inst$nf.age.grp

# By Race
md.race.main.ARTnet_N_MO_script[[i]] <- out$main$nf.race
md.race.casl.ARTnet_N_MO_script[[i]] <- out$casl$nf.race
md.race.inst.ARTnet_N_MO_script[[i]] <- out$inst$nf.race

# By Diagnosed HIV Status
md.HIV_status.main.ARTnet_N_MO_script[[i]] <- out$main$nf.diag.status
md.HIV_status.casl.ARTnet_N_MO_script[[i]] <- out$casl$nf.diag.status
md.HIV_status.inst.ARTnet_N_MO_script[[i]] <- out$inst$nf.diag.status

# By Cross Partnership Degree
md.casl_cross_deg.main.ARTnet_N_MO_script[[i]] <- out$main$nf.deg.casl
md.main_cross_deg.casl.ARTnet_N_MO_script[[i]] <- out$casl$nf.deg.main


## Proportion Concurrent
prop.concurrent.main.ARTnet_N_MO_script[[i]] <- out$main$concurrent
prop.concurrent.casl.ARTnet_N_MO_script[[i]] <- out$casl$concurrent


## Mixing

# By Age - Overall
mixing.age.overall.main.ARTnet_N_MO_script[[i]] <- out$main$nm.age.grp_diffF
mixing.age.overall.casl.ARTnet_N_MO_script[[i]] <- out$casl$nm.age.grp_diffF
mixing.age.overall.inst.ARTnet_N_MO_script[[i]] <- out$inst$nm.age.grp_diffF

# By Age - Within Age Group
mixing.age.within_group.main.ARTnet_N_MO_script[[i]] <- out$main$nm.age.grp
mixing.age.within_group.casl.ARTnet_N_MO_script[[i]] <- out$casl$nm.age.grp
mixing.age.within_group.inst.ARTnet_N_MO_script[[i]] <- out$inst$nm.age.grp

# By Race - Overall
mixing.race.overall.main.ARTnet_N_MO_script[[i]] <- out$main$nm.race_diffF
mixing.race.overall.casl.ARTnet_N_MO_script[[i]] <- out$casl$nm.race_diffF
mixing.race.overall.inst.ARTnet_N_MO_script[[i]] <- out$inst$nm.race_diffF

# By Race - Within Race Group
mixing.race.within_group.main.ARTnet_N_MO_script[[i]] <- out$main$nm.race
mixing.race.within_group.casl.ARTnet_N_MO_script[[i]] <- out$casl$nm.race
mixing.race.within_group.inst.ARTnet_N_MO_script[[i]] <- out$inst$nm.race


## Mean Duration
duration.main.ARTnet_N_MO_script[[i]] <- durs.main.all$mean.dur.adj
duration.casl.ARTnet_N_MO_script[[i]] <- durs.casl.all$mean.dur.adj


## One-Time Partner Rates 

# By Main+Casual Degree
OTP.rates.by.degree.ARTnet_N_MO_script[[i]] <- out$inst$nf.deg.tot

# By Risk Quintile
OTP.rates.by.risk.ARTnet_N_MO_script[[i]] <- out$inst$nf.risk.grp

}

```

\newpage
Here are the results comparing mean degree by partnership type (main or casual) and method of determining ongoing partnerships (day-of-survey or three-month offset) in table form:

```{r comparison, warning=FALSE, include=FALSE}

Partnership.Type <- rbind(c("Main"),c("Casual"))

mean.degree.main <- data.frame(round(out_dos$main$md.main,4), round(out_list[[3]][[1]][[1]][1],4))
colnames(mean.degree.main) <- c("Day-of-Survey", "Three-Month")

mean.degree.casl <- data.frame(round(out_dos$casl$md.casl,4), round(out_list[[3]][[2]][[1]][1],4))
colnames(mean.degree.casl) <- c("Day-of-Survey", "Three-Month")

mean.degree.df <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(mean.degree.df) <- c("Day-of-Survey", "Three-Month")

mean.degree.df <- rbind(mean.degree.df, mean.degree.main, mean.degree.casl)

mean.degree.df

```

```{r comparison_final, warning=FALSE, echo=FALSE}
mean.degree.df.final <- data.frame(matrix(ncol = 3, nrow = 0))
colnames(mean.degree.df.final) <- c("Type","Day-of-Survey","Three.Month")

mean.degree.df.final <- cbind(Partnership.Type, mean.degree.df)

kable(mean.degree.df.final) %>%
  kable_styling(bootstrap_options = "striped", font_size = 12)

```

The mean degree by partnership type calculated using the day-of-survey and three-month offset methods are similar.

Next, instead of assessing ongoing partnerships using a three-month offset, we can generalize our approach to look at n-month offsets for user specified values of n.

For the purpose of this example, we assessed ongoing partnerships with one- to twelve- month offsets and reviewed how mean degree would change depending on months of offset.

The pairs of plots below show how mean degree changes depending on number of months of offset used for determination of whether or not a partnership is ongoing. The plots show the same data, with the second pair of plots showing the results at larger scale.

The data may also be viewed in the table below the pair of plots.

\newpage
```{r plots_tables, fig.align='center', fig.height=8, echo=FALSE}
# RESULTS

par(mfrow=c(2,2))

plot(1:13, md.overall.main.ARTnet_N_MO_script, 
     main = "\n\n\nMain Partnerships",
     xlab = "Number of Offset Months",
     ylab = "Mean Degree",
     ylim = c(0,1),
     xaxt = "n",
     cex.main = 0.8)
axis(1, at=1:13, labels=0:12)
abline(h=out_dos$main$md.main, col="blue")
text(0.45*(12 - 0),
     1.12*out_dos$main$md.main,
     paste("Mean Degree:\nDay-of-Survey Method = ",round(out_dos$main$md.main,4),sep=""),
     cex = 0.5,
     adj = 0)

plot(1:13, md.overall.casl.ARTnet_N_MO_script, 
     main = "\n\n\nCasual Partnerships", 
     xlab = "Number of Offset Months",
     ylab = "Mean Degree",
     ylim = c(0,1),
     xaxt = "n",
     cex.main = 0.8)
axis(1, at=1:13, labels=0:12)
abline(h=out_dos$casl$md.casl, col="purple")
text(0.45*(12 - 0),
     1.1*out_dos$casl$md.casl,
     paste("Mean Degree:\nDay-of-Survey Method = ",round(out_dos$casl$md.casl,4),sep=""),
     cex = 0.5,
     adj = 0)
mtext("Partnership Mean Degree", side = 3, line = -1, outer = TRUE, font = 2)
mtext("N-Month Offset Method - Points, Day-of-Survey Method - Line", side = 3, line = -2, outer = TRUE, font = 2, cex = 0.75)

plot(1:13, md.overall.main.ARTnet_N_MO_script, 
     main = "Main Partnerships - Scaled",
     xlab = "Number of Offset Months",
     ylab = "Mean Degree",
     xaxt = "n",
     cex.main = 0.8)
axis(1, at=1:13, labels=0:12)
abline(h=out_dos$main$md.main, col="blue")
text(0.3*(12 - 0),
     0.99*out_dos$main$md.main,
     paste("Mean Degree:\nDay-of-Survey Method = ",round(out_dos$main$md.main,4),sep=""),
     cex = .5,
     adj = 0)

plot(1:13, md.overall.casl.ARTnet_N_MO_script, 
     main = "Casual Partnerships - Scaled",
     xlab = "Number of Offset Months",
     ylab = "Mean Degree",
     xaxt = "n",
     cex.main = 0.8)
axis(1, at=1:13, labels=0:12)
abline(h=out_dos$casl$md.casl, col="purple")
text(0.45*(12 - 0),
     1.01*out_dos$casl$md.casl,
     paste("Mean Degree:\nDay-of-Survey Method = ",round(out_dos$casl$md.casl,4),sep=""),
     cex = .5,
     adj = 0)

par(xpd = TRUE)
text(par("usr")[2] - 18,y=mean(par("usr")[3:4]) + 0,"test taxis label",srt=-270)

n_month <- 0:12

#Mean degree - main
mean.degree.main.df <- data.frame(n_month, round(unlist(md.overall.main.ARTnet_N_MO_script),4))

#Mean degree - casual
mean.degree.casual.df <- data.frame(n_month, round(unlist(md.overall.casl.ARTnet_N_MO_script),4))

mean.degree.table <- mean.degree.main.df %>%
  left_join(mean.degree.casual.df, by = "n_month")
colnames(mean.degree.table) <- c("Month", "Main", "Casual")

mean.degree.table <- setNames(data.frame(t(mean.degree.table[,-1])), mean.degree.table[,1])

dos_ref_col <- rbind(c(round(out_dos$main$md.main,4)),c(round(out_dos$casl$md.casl,4)))
colnames(dos_ref_col) <- c("Day-of-Survey")

mean.degree.table <- cbind(dos_ref_col, mean.degree.table)

kable(mean.degree.table) %>%
  kable_styling(bootstrap_options = "striped", font_size = 6)

```
